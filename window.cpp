/**
 * @file      window.cpp
 * @brief     Definition of GUI window class
 * @version   0.1
 * @author    dragon-archer
 *
 * @copyright Copyright (c) 2022
 */

#include "pch_gui.h"
#include "window.h"
#include "ui_window.h" // Note: generated by UIC from window.ui

Window::Window(QWidget* parent)
	: QWidget(parent)
	, ui(new Ui::Window) {
	ui->setupUi(this);
	for(int i = 0; i < ui->m_board->rowCount(); ++i) {
		for(int j = 0; j < ui->m_board->columnCount(); ++j) {
			ui->m_board->setItem(i, j, new QTableWidgetItem());
		}
	}
}

Window::~Window() {
	delete ui;
}

void Window::onBoardItemClicked(int row, int col) {
	ui->m_board->setCurrentCell(row, col, QItemSelectionModel::Clear);
	if(!gameContinue) {
		return;
	}
	addTextToInfo(tr("You selected (%1, %2)").arg(row + 1).arg(col + 1));
	bool ok = doMove(row, col, P_PLAYER1);
	if(!ok) {
		return;
	}
	auto [ai_row, ai_col] = ai_move(game, P_PLAYER2);
	addTextToInfo(tr("AI selected (%1, %2)").arg(ai_row + 1).arg(ai_col + 1));
	doMove(ai_row, ai_col, P_PLAYER2);
}

void Window::onBtnRestart() {
	game.reset();
	// Clear the screen
	for(int i = 0; i < ui->m_board->rowCount(); ++i) {
		for(int j = 0; j < ui->m_board->columnCount(); ++j) {
			ui->m_board->item(i, j)->setBackground(QBrush());
		}
	}
	updateSteps();
	ui->m_labelInfo->clear();
	gameContinue = true;
}

void Window::onBtnUndo() {
	if(game.steps() < 2) {
		addTextToInfo(tr("Undo failed: Nothing to do"));
		return;
	}
	auto [r1, c1] = game.revert();
	auto [r2, c2] = game.revert();
	ui->m_board->item(r1, c1)->setBackground(QBrush());
	ui->m_board->item(r2, c2)->setBackground(QBrush());
	updateSteps();
	gameContinue = true;
	addTextToInfo(tr("Undo succeeded"));
}

bool Window::doMove(int x, int y, Player role) {
	auto ret = game.move(x, y, role);
	updateSteps();
	switch(ret) {
	case R_OK: {
		auto item = ui->m_board->item(x, y);
		item->setBackground(QBrush(player_color[role]));
		return true;
	}
	case R_WIN: {
		auto item = ui->m_board->item(x, y);
		item->setBackground(QBrush(player_color[role]));
		addTextToInfo((role == P_PLAYER1) ? tr("You wins!") : tr("AI wins!"));
		gameContinue = false;
		return false;
	}
	case R_OUT_OF_RANGE: {
		addTextToInfo(tr("Out of range"));
		return false;
	}
	case R_OCCUPIED: {
		addTextToInfo(tr("Occupied"));
		return false;
	}
	default: {
		addTextToInfo(tr("Internal error"));
		gameContinue = false;
		return false;
	}
	};
}

void Window::updateSteps() {
	// As game.steps() include AI steps, it should be divided by 2
	ui->m_labelSteps->setText(QString::number(int(game.steps() + 1) / 2));
}

void Window::addTextToInfo(const QString& text) {
	QString oldText = ui->m_labelInfo->text();
	if(!oldText.isEmpty()) {
		oldText += '\n';
	}
	ui->m_labelInfo->setText(oldText + text);
}
